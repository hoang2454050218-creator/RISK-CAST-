"""
Base classes for internal signal analyzers.

Every analyzer:
- Takes a DB query layer + optional OmenClient
- Outputs a list of InternalSignal
- Is isolated: one analyzer failure does not block others
"""

from abc import ABC, abstractmethod

from pydantic import BaseModel, Field


class InternalSignal(BaseModel):
    """A signal generated by an internal analyzer."""

    source: str = Field(description="e.g. internal_payment, internal_route, internal_order")
    signal_type: str = Field(description="e.g. payment_risk, route_disruption, order_risk_composite")
    entity_type: str = Field(description="e.g. customer, route, order")
    entity_id: str = Field(description="UUID of the entity")
    confidence: float = Field(ge=0, le=1, description="Data quality / confidence")
    severity_score: float = Field(ge=0, le=100, description="How severe (0-100)")
    evidence: dict = Field(description="Supporting data for this signal")
    context: dict = Field(default_factory=dict, description="Human-readable context")


class BaseAnalyzer(ABC):
    """
    Abstract base for all signal analyzers.

    Subclasses implement analyze() which scans company data
    and returns signals found.
    """

    def __init__(self, db_queries, omen_client=None):
        self.db = db_queries
        self.omen_client = omen_client

    @abstractmethod
    async def analyze(self, company_id: str) -> list[InternalSignal]:
        """Analyze company data and return signals found."""
        ...
